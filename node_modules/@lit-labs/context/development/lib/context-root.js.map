{"version":3,"file":"context-root.js","sourceRoot":"","sources":["../../src/lib/context-root.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAiB,mBAAmB,EAAC,MAAM,4BAA4B,CAAC;AAa/E;;;GAGG;AACH,MAAM,OAAO,WAAW;IAAxB;QACU,2BAAsB,GAAG,IAAI,GAAG,EAGrC,CAAC;QAuBI,sBAAiB,GAAG,CAC1B,EAAmD,EACnD,EAAE;YACF,MAAM,eAAe,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;YACpE,IAAI,CAAC,eAAe,EAAE;gBACpB,OAAO,CAAC,qDAAqD;aAC9D;YAED,wEAAwE;YACxE,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;YAE/C,wEAAwE;YACxE,eAAe,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAClC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;gBAChC,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,2DAA2D;gBAC3D,IAAI,OAAO,EAAE;oBACX,OAAO,CAAC,aAAa,CACnB,IAAI,mBAAmB,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,EAAE,IAAI,CAAC,CACpD,CAAC;iBACH;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;QAEM,qBAAgB,GAAG,CACzB,EAAkD,EAClD,EAAE;YACF,yDAAyD;YACzD,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE;gBACjB,OAAO;aACR;YACD,wDAAwD;YACxD,MAAM,OAAO,GAA0B;gBACrC,OAAO,EAAE,EAAE,CAAC,MAAqB;gBACjC,QAAQ,EAAE,EAAE,CAAC,QAAQ;aACtB,CAAC;YACF,IAAI,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;YACzE,IAAI,CAAC,sBAAsB,EAAE;gBAC3B,sBAAsB,GAAG,IAAI,GAAG,EAAE,CAAC;gBACnC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,sBAAsB,CAAC,CAAC;aACrE;YACD,sEAAsE;YACtE,mEAAmE;YACnE,mCAAmC;YACnC,sBAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC,CAAC;IACJ,CAAC;IAnEC;;;;;OAKG;IACI,MAAM,CAAC,OAAoB;QAChC,OAAO,CAAC,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACnE,OAAO,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACvE,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,OAAoB;QAChC,OAAO,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACtE,OAAO,CAAC,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAC1E,CAAC;CAgDF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Context} from './create-context.js';\nimport {ContextRequest, ContextRequestEvent} from './context-request-event.js';\nimport {ContextProviderEvent} from './controllers/context-provider.js';\n\ntype UnknownContextKey = Context<unknown, unknown>;\n\n/**\n * A context request, with associated source element, with all objects as weak references.\n */\ntype PendingContextRequest = Omit<\n  ContextRequest<UnknownContextKey>,\n  'context' | 'subscribe'\n> & {element: HTMLElement};\n\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and redispatch these\n * requests when new providers which satisfy matching context keys are available.\n */\nexport class ContextRoot {\n  private pendingContextRequests = new Map<\n    UnknownContextKey,\n    Set<PendingContextRequest>\n  >();\n\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  public attach(element: HTMLElement): void {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  public detach(element: HTMLElement): void {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n\n  private onContextProvider = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ) => {\n    const pendingRequests = this.pendingContextRequests.get(ev.context);\n    if (!pendingRequests) {\n      return; // no pending requests for this provider at this time\n    }\n\n    // clear our list, any still unsatisfied requests will re-add themselves\n    this.pendingContextRequests.delete(ev.context);\n\n    // loop over all pending requests and re-dispatch them from their source\n    pendingRequests.forEach((request) => {\n      const element = request.element;\n      const callback = request.callback;\n      // redispatch if we still have all the parts of the request\n      if (element) {\n        element.dispatchEvent(\n          new ContextRequestEvent(ev.context, callback, true)\n        );\n      }\n    });\n  };\n\n  private onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ) => {\n    // events that are not subscribing should not be captured\n    if (!ev.subscribe) {\n      return;\n    }\n    // store a weakref to this element under the context key\n    const request: PendingContextRequest = {\n      element: ev.target as HTMLElement,\n      callback: ev.callback,\n    };\n    let pendingContextRequests = this.pendingContextRequests.get(ev.context);\n    if (!pendingContextRequests) {\n      pendingContextRequests = new Set();\n      this.pendingContextRequests.set(ev.context, pendingContextRequests);\n    }\n    // NOTE: if the element is connected multiple times it will add itself\n    // to this set multiple times since the set identify of the request\n    // object will be unique each time.\n    pendingContextRequests.add(request);\n  };\n}\n"]}